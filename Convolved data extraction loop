for quantum in range(14,21):
    print(quantum)
    import numpy as np
    import numpy.ma as ma
    import matplotlib.pyplot as plt
    import pandas as pd
    import scipy as sci
    from scipy import interpolate
    from astropy.table import Table
    t = Table.read('/home/parallels/NIUS/Temp/lte0{}-3.5-0.0.BT-Settl.7.dat.xml'.format(quantum))
    #print(t)
    from astropy.io.votable import parse_single_table
    table = parse_single_table('/home/parallels/NIUS/Temp/lte0{}-3.5-0.0.BT-Settl.7.dat.xml'.format(quantum))
    #print(table)

    data = table.array

    # Lambda_0 = 5000 Angstrom
    lambda_o = 5000  # # # This is the confusion. What are we supposed to take this lambda not.
    i = (np.pi)/6         # in radian
    c = sci.constants.c # speed of light
    G = sci.constants.G        #gravitational constant
    M_star = 10**30    # mass of proto-star in consideration
    R = 10**7         # Radius
    v_kep = 300000 # # (G*M_star/R)**0.5      # in metres per second
    #print('v keplerian: {} in metres per sec'.format(v_kep))
    np.sin(i)/(c) * v_kep
    lambda_max =  (lambda_o * np.sin(i))/(c) * v_kep
    #print(lambda_max)

    #finding initial sampling rate of the data
    trimmed_data = np.extract(data['WAVELENGTH']>3000,data)
    trimmed_data = np.extract(trimmed_data['WAVELENGTH']<50000,trimmed_data)
    #print(trimmed_data[0],trimmed_data[-1])
    # Sampling rate at Lambda not 
    trim_dta = np.extract(trimmed_data['WAVELENGTH']>(lambda_o-lambda_max),trimmed_data)
    trim_dta = np.extract(trim_dta['WAVELENGTH']<(lambda_o+lambda_max),trim_dta)
    trim_dta
    #print('Sampling rate at lambda_0: ',len(trim_dta))
    #sampling at initial lambda
    trim_dta_2 = np.extract(trimmed_data['WAVELENGTH']<(trimmed_data['WAVELENGTH'][0]+(2*lambda_max)),trimmed_data)
    #print(trim_dta_2)
    #print(len(trim_dta_2))
    #print('Initial Sampling rate at lambda_i: ',len(trim_dta_2))
    #sampling at final lambda
    trim_dta_3 = np.extract(trimmed_data['WAVELENGTH']>(trimmed_data['WAVELENGTH'][-1]-(2*lambda_max)),trimmed_data)
    trim_dta_3
    #print('Initial Sampling rate at lambda_f: ',len(trim_dta_3))

    trim_x = np.extract(data['WAVELENGTH']>3000,data['WAVELENGTH'])
    trim_x = np.extract(trim_x<50000,trim_x)
    #print(trim_x[0],trim_x[-1])
    x_dash = trim_x

    trim_y = np.extract(data['WAVELENGTH']>3000,data['FLUX'])
    trim_y = np.extract(trim_x<50000,trim_y)
    #print(trim_y[0],trim_y[-1])
    y_dash = trim_y

    diff_in_wave = [0]
    for i in range(len(x_dash)-1):
        diff_dash = x_dash[i+1]-x_dash[i]
        diff_in_wave.append(diff_dash)
    #print(diff_wavelength_dash)
    #print(len(diff_in_wave))
    #plt.plot(x_dash,np.log10(diff_in_wave))
    diff_in_wave[-1]

    print('kernel width: {}'.format(lambda_max*2))
    #Writing the kernel
    #x_inter
    para_1 = lambda_o-lambda_max
    para_2 = lambda_o+lambda_max
    para_3 = len(trim_dta_2)
    #print(para_1, para_2, para_3)
    ax = np.linspace(para_1,para_2,para_3,False)
    y_ker = (1-((ax-lambda_o)/lambda_max)**2)**(-0.5)
    y_ker = np.ma.masked_invalid(y_ker)
    y_ker = np.ma.filled(y_ker, 0)
    ax=np.delete(ax,0)
    y_ker=np.delete(y_ker,0)
    #plt.plot(ax,y_ker,)
    # y_ker.count()
    w = np.count_nonzero(y_ker)
    #print(y_ker[0])
    # normalise the kernel
    final_kernel = y_ker/np.sum(y_ker)
    #plt.plot(ax,final_kernel)

    #define a new linspace
    len(diff_in_wave)
    new_difference = np.linspace(diff_in_wave[0],0.223755,len(diff_in_wave)) # the final value how to approach in proper method
    #plt.plot(x,wave_dash)
    #wave_dash
    #print(new_difference)
    cumsumm = [0]

    for i in range(len(new_difference)):
        xx = new_difference[i] + cumsumm[-1]
        cumsumm.append(xx)
    #cf = np.cumsum(new_difference)
    #print(cumsumm)
    '''x_new = [3000]
    for i in range(len(cf)-1):
    new_ele =  cf[i] - x_new[-1]
    x_new.append(new_ele)
    len(x_new)
    x_new[-1]'''
    #new_x = np.linspace(3000,50000,420051)
    #plt.plot(new_x,cf)
    cf = []
    for i in range(len(diff_in_wave)):
        cs = 3000 + cumsumm[i]
        cf.append(cs)
    diff_in_wave[-3]
    cf[-1]

    # interpolate with a fixed function throughout
    cf
    y_dash
    f = interpolate.interp1d(x_dash,y_dash)
    x_after_inter = np.linspace(3000.1,49999.00,len(diff_in_wave))
    new_y = f(x_after_inter)
    convolved_curve = np.convolve(new_y, final_kernel, mode='same')
    plt.plot(x_dash,np.log10(y_dash),'b',x_after_inter,np.log10(convolved_curve),'r')
